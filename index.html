<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ribbons 360 — Shimmer</title>
<style>
  :root { --bg: #05070b; }
  html, body { margin:0; height:100%; background:#000; color:#cfd8e3; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
  #view { display:block; width:100vw; height:auto; max-height:100vh; margin:0 auto; background:#000; }
  .hud {
    position: fixed; left:12px; top:12px; z-index:5; max-width:min(560px,92vw);
    background:rgba(10,14,18,.6); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:10px 12px;
    backdrop-filter: blur(6px); display:none;
  }
  .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:6px}
  .btn{display:inline-block; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:#e6edf7; user-select:none; cursor:pointer}
  kbd{font:600 12px/1 ui-monospace,Menlo,Consolas,monospace; padding:2px 6px; border-radius:6px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12)}
</style>
</head>
<body>
<canvas id="view"></canvas>

<div class="hud" id="hud">
  <div><strong>Controls</strong></div>
  <div style="margin-top:6px">
    <div><kbd>1</kbd> show/hide this panel</div>
    <div><kbd>M</kbd> mute • <kbd>P</kbd> pause • <kbd>C</kbd> clear • <kbd>F</kbd> fullscreen</div>
    <div><kbd>←/→</kbd> mod depth • <kbd>Shift</kbd>+<kbd>←/→</kbd> LFO rate • <kbd>↑/↓</kbd> reverb mix</div>
  </div>
  <div class="row" style="margin-top:6px">
    <span class="btn" id="clearBtn">Clear</span>
    <span class="btn" id="pauseBtn">Pause</span>
    <span class="btn" id="muteBtn">Unmuted</span>
  </div>
  <div id="readout" style="margin-top:8px;opacity:.9"></div>
</div>

<script>
/* =========================
   CANVAS: 5360×1080 offscreen + preview
   ========================= */
const WALL_W = 5360, WALL_H = 1080;
const buf = document.createElement('canvas'); buf.width = WALL_W; buf.height = WALL_H;
const btx = buf.getContext('2d', { alpha:false });
const view = document.getElementById('view'), vtx = view.getContext('2d');

function sizePreview(){
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const ww = innerWidth, wh = innerHeight, aspect = WALL_W/WALL_H;
  let w = ww, h = Math.floor(ww/aspect); if (h>wh){ h=wh; w=Math.floor(wh*aspect); }
  view.style.width = w+'px'; view.style.height = h+'px';
  view.width = Math.floor(w*DPR); view.height = Math.floor(h*DPR);
  vtx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', sizePreview, {passive:true}); sizePreview();

function clearBuffer() {
  btx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#05070b';
  btx.fillRect(0,0,WALL_W,WALL_H);
}
clearBuffer();

/* =========================
   KEY → COLOR / PITCH MAPPING
   ========================= */
const rows = ["`1234567890-=","qwertyuiop[]\\","asdfghjkl;'", "zxcvbnm,./"];
function keyToIndex(k){
  if(!k) return {idx:0,max:1};
  const key=k.toLowerCase();
  for(const row of rows){ const i=row.indexOf(key); if(i>=0) return {idx:i,max:row.length-1}; }
  const i=Math.max(0,Math.min(11,(key.charCodeAt(0)||0)%12));
  return {idx:i,max:11};
}
function lightnessForKey(key){ const {idx,max}=keyToIndex(key); const t=max?idx/max:0; return 72 - t*(72-30); }
function soundForKey(key){
  const {idx,max}=keyToIndex(key); const t=max?idx/max:0;
  const freq = 880 - t*(880-110);         // left high → right low
  const cutoff = 12000 - t*10000;         // brightness tie-in
  return {t,freq,cutoff};
}

/* =========================
   RIBBONS (colorful, shimmer, ≤3s linger)
   ========================= */
let paused=false;
const ribbons = []; // {pts, vx, vy, hue, sat, baseL, width, born, life, dashPhase, dashSpeed, jitter}

function spawnRibbonFromKey(key){
  const {t,freq} = soundForKey(key);
  const baseL = lightnessForKey(key);                  // keep lightness below white
  const hue0  = (key.charCodeAt(0)*11) % 360;
  const sat   = 86;

  // Horizontal motion (left→right), low→wider sweep; high pitch rises more.
  const vx = 200 + (1-t)*140;                          // 200–340 px/s
  const pitch01 = (freq-110)/(880-110);
  const vy = -60 * pitch01 + 8*(1-pitch01);            // up to ~-60 px/s upward

  const x0 = (Math.random()*WALL_W)|0;
  const y0 = Math.round(WALL_H*0.40 + (Math.random()-0.5)*WALL_H*0.22);

  const width = 4 + (1-t)*5;                           // thicker on lower notes
  const now = performance.now();

  ribbons.push({
    pts:[{x:x0,y:y0}],
    vx, vy,
    hue:hue0, sat, baseL,
    width,
    born: now,
    life: 1800 + Math.random()*500,                    // emits for ~1.8–2.3s
    dashPhase: Math.random()*200,
    dashSpeed: 120 + Math.random()*160,                // shimmer speed
    jitter: 8 + Math.random()*16                       // path wobble amplitude
  });
}

// Toroidal wrap helpers (horizontal)
function wrapX(x){ x%=WALL_W; if(x<0) x+=WALL_W; return x; }
function strokeWrapped(draw){
  for(let k=-1;k<=1;k++){ btx.save(); btx.translate(k*WALL_W,0); draw(btx); btx.restore(); }
}

let lastT = performance.now();
// Fade alpha ~0.025 ⇒ ~1% remaining after ~3s @60fps
const TRAIL_FADE_ALPHA = 0.025;

function frame(t){
  // Gentle global fade to cap persistence ≲ 3s
  btx.fillStyle = `rgba(5,7,11,${TRAIL_FADE_ALPHA})`;
  btx.fillRect(0,0,WALL_W,WALL_H);

  if(!paused){
    const dt = Math.min(0.05,(t-lastT)/1000); lastT=t;

    for(let i=ribbons.length-1;i>=0;i--){
      const r = ribbons[i];
      const age = t - r.born;

      // Emit new point
      const head = r.pts[r.pts.length-1];
      const wob = Math.sin((t + i*137)%100000 / 180) * r.jitter;  // mild shimmer in path
      const nx = wrapX(head.x + r.vx*dt);
      let ny = head.y + (r.vy*dt) + wob*dt;
      if(ny<0) ny=0; if(ny>WALL_H) ny=WALL_H;
      r.pts.push({x:nx,y:ny});

      // Keep recent points only (short trails per ribbon)
      const maxPts = 160;
      if(r.pts.length>maxPts) r.pts.splice(0, r.pts.length-maxPts);

      // Shimmer: dash phase drifts; hue breathes a bit
      r.dashPhase -= r.dashSpeed * dt;
      const hue = (r.hue + (age*0.02) + Math.sin(t*0.003+i)*10) % 360;
      const l = Math.max(22, r.baseL - Math.min(1, age/r.life)*8); // don’t let it blow out
      const strokeColor = `hsl(${hue} ${r.sat}% ${l}%)`;
      const glowColor   = `hsla(${hue} ${r.sat}% ${Math.min(l+8, 65)}%, 0.85)`;

      strokeWrapped((ctx)=>{
        ctx.save();
        ctx.globalCompositeOperation = 'source-over'; // avoid additive white
        ctx.lineWidth = r.width * (0.92 + 0.08*Math.cos(t*0.005 + i));
        ctx.lineJoin = 'round';
        ctx.lineCap  = 'round';

        // Soft colored glow instead of additive white
        ctx.shadowBlur = 18;
        ctx.shadowColor = glowColor;

        // Shimmer via moving dash
        ctx.setLineDash([24, 18, 10, 22]);
        ctx.lineDashOffset = r.dashPhase;

        // Gradient along the latest segment to add color richness
        const p0 = r.pts[0], p1 = r.pts[r.pts.length-1];
        const grad = ctx.createLinearGradient(p0.x, p0.y, p1.x, p1.y);
        grad.addColorStop(0, `hsl(${(hue+160)%360} ${r.sat}% ${Math.max(18,l-10)}%)`);
        grad.addColorStop(1, strokeColor);
        ctx.strokeStyle = grad;

        ctx.beginPath();
        const pts = r.pts;
        for(let j=0;j<pts.length;j++){
          const p = pts[j];
          if(j===0) ctx.moveTo(p.x,p.y);
          else {
            const prev = pts[j-1];
            const mx=(prev.x+p.x)/2, my=(prev.y+p.y)/2;
            ctx.quadraticCurveTo(prev.x,prev.y,mx,my);
          }
        }
        ctx.stroke();

        // Cleanup
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;
        ctx.restore();
      });

      // Retire ribbon shortly after emission stops
      if(age > r.life + 1200 && r.pts.length < 24) ribbons.splice(i,1);
    }
  }

  // Present to preview
  vtx.clearRect(0,0,view.width,view.height);
  vtx.drawImage(buf, 0, 0, view.width, view.height);

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* =========================
   AUDIO: Reverb + LFO (as before)
   ========================= */
let audioCtx, master, compressor, convolver, wetGain, dryGain, lfoOsc, lfoGain, muted=false;
const params = {
  lfoRate: 3.0, lfoRateMin: 0.1, lfoRateMax: 12,
  modDepthFilter: 400, modDepthFilterMin: 0, modDepthFilterMax: 2000,
  modDepthPitch: 4,   modDepthPitchMin: 0, modDepthPitchMax: 20,
  reverbMix: 0.26, reverbDecay: 2.2
};
const readout = document.getElementById('readout');
function updateHUD(){
  readout.textContent =
    `LFO: ${params.lfoRate.toFixed(2)} Hz  |  Mod(filter): ${Math.round(params.modDepthFilter)} Hz  |  Mod(pitch): ${params.modDepthPitch.toFixed(1)} Hz  |  Reverb: ${(params.reverbMix*100|0)}%  |  ribbons: ${ribbons.length}`;
}
updateHUD();

document.getElementById('muteBtn').onclick = () => {
  muted = !muted; if(master) master.gain.value = muted ? 0 : 0.9;
  document.getElementById('muteBtn').textContent = muted ? 'Muted' : 'Unmuted';
};
document.getElementById('pauseBtn').onclick = (e) => { paused=!paused; e.target.textContent = paused ? 'Resume' : 'Pause'; };
document.getElementById('clearBtn').onclick = () => { clearBuffer(); ribbons.length = 0; };

function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  master = audioCtx.createGain(); master.gain.value = 0.9;
  compressor = audioCtx.createDynamicsCompressor();
  compressor.threshold.setValueAtTime(-24, audioCtx.currentTime);
  compressor.knee.setValueAtTime(30, audioCtx.currentTime);
  compressor.ratio.setValueAtTime(6, audioCtx.currentTime);
  compressor.attack.setValueAtTime(0.003, audioCtx.currentTime);
  compressor.release.setValueAtTime(0.25, audioCtx.currentTime);

  convolver = audioCtx.createConvolver();
  convolver.buffer = makeImpulseResponse(audioCtx, params.reverbDecay, 0.35);
  wetGain = audioCtx.createGain(); dryGain = audioCtx.createGain();
  setReverbMix(params.reverbMix);

  lfoOsc = audioCtx.createOscillator(); lfoOsc.type='sine'; lfoOsc.frequency.value = params.lfoRate;
  lfoGain = audioCtx.createGain(); lfoGain.gain.value = 1;
  lfoOsc.connect(lfoGain); lfoOsc.start();

  dryGain.connect(compressor); wetGain.connect(compressor); compressor.connect(audioCtx.destination);
}
function makeImpulseResponse(ctx, seconds=2.0, decay=0.35){
  const rate=ctx.sampleRate, len=Math.max(1,(seconds*rate)|0); const buf=ctx.createBuffer(2,len,rate);
  for(let ch=0; ch<2; ch++){ const d=buf.getChannelData(ch); for(let i=0;i<len;i++){ d[i]=(Math.random()*2-1)*Math.pow(1-i/len, decay*6); } }
  return buf;
}
function setReverbMix(mix){
  params.reverbMix=Math.min(1,Math.max(0,mix));
  if(!dryGain||!wetGain) return;
  const x=params.reverbMix; dryGain.gain.value=Math.cos(x*Math.PI/2); wetGain.gain.value=Math.sin(x*Math.PI/2);
  updateHUD();
}
function playPercussiveTone(key){
  ensureAudio(); if(!audioCtx) return;
  const now=audioCtx.currentTime;
  const {freq,cutoff,t}=soundForKey(key);

  const osc=audioCtx.createOscillator(); osc.type=t<0.5?'triangle':'sawtooth'; osc.frequency.setValueAtTime(freq,now);
  const filter=audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.setValueAtTime(cutoff,now); filter.Q.setValueAtTime(0.7+t*0.6,now);

  const env=audioCtx.createGain(); env.gain.setValueAtTime(0,now); env.gain.linearRampToValueAtTime(0.9,now+0.005); env.gain.exponentialRampToValueAtTime(0.0008,now+0.35+t*0.15);

  const noise=audioCtx.createBufferSource(); const buffer=audioCtx.createBuffer(1,audioCtx.sampleRate*0.1,audioCtx.sampleRate);
  const data=buffer.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*Math.exp(-i/(data.length*0.25));
  noise.buffer=buffer; const env2=audioCtx.createGain(); env2.gain.setValueAtTime(0.6,now); env2.gain.exponentialRampToValueAtTime(0.0008,now+0.08+t*0.05);

  // LFO sends
  const lfoToFilter=audioCtx.createGain(); lfoToFilter.gain.value=params.modDepthFilter;
  const lfoToPitch=audioCtx.createGain();  lfoToPitch.gain.value=params.modDepthPitch;
  lfoGain.connect(lfoToFilter); lfoToFilter.connect(filter.frequency);
  lfoGain.connect(lfoToPitch);  lfoToPitch.connect(osc.frequency);

  const wet=audioCtx.createGain(), dry=audioCtx.createGain();
  osc.connect(filter); filter.connect(env); env.connect(dry); env.connect(wet);
  noise.connect(env2); env2.connect(dry); env2.connect(wet);
  wet.connect(convolver); convolver.connect(wetGain); dry.connect(dryGain);

  osc.start(now); noise.start(now);
  osc.stop(now + 0.6 + t*0.2); noise.stop(now + 0.12 + t*0.05);
}

/* =========================
   INPUT: keys & UI toggles
   ========================= */
const hud = document.getElementById('hud');
addEventListener('keydown', async (e)=>{
  // Toggle instructions
  if(e.key === '1'){ hud.style.display = (hud.style.display==='none' || !hud.style.display) ? 'block' : 'none'; return; }

  if(handleControlKeys(e)) return;
  if(e.repeat) return;
  const k = e.key.length===1 ? e.key : '';
  if(!k) return;

  ensureAudio();
  if(audioCtx && audioCtx.state==='suspended'){ try{ await audioCtx.resume(); }catch{} }

  spawnRibbonFromKey(k);
  if(!muted) playPercussiveTone(k);
});

function handleControlKeys(e){
  const k=e.key;
  if(k==='m'||k==='M'){ muted=!muted; if(master) master.gain.value=muted?0:0.9; document.getElementById('muteBtn').textContent=muted?'Muted':'Unmuted'; e.preventDefault(); return true; }
  if(k==='p'||k==='P'){ paused=!paused; document.getElementById('pauseBtn').textContent=paused?'Resume':'Pause'; e.preventDefault(); return true; }
  if(k==='c'||k==='C'){ clearBuffer(); ribbons.length=0; e.preventDefault(); return true; }
  if(k==='f'||k==='F'){ toggleFullscreen(); e.preventDefault(); return true; }
  if(k==='ArrowLeft'||k==='ArrowRight'||k==='ArrowUp'||k==='ArrowDown'){
    ensureAudio(); if(!audioCtx) return true;
    if(k==='ArrowLeft'||k==='ArrowRight'){
      const delta=(e.shiftKey?0:1)*(k==='ArrowRight'?60:-60);
      params.modDepthFilter = clamp(params.modDepthFilter+delta, params.modDepthFilterMin, params.modDepthFilterMax);
      params.modDepthPitch  = clamp((params.modDepthFilter/100), params.modDepthPitchMin, params.modDepthPitchMax);
    }
    if(e.shiftKey && (k==='ArrowLeft'||k==='ArrowRight')){
      const rDelta=(k==='ArrowRight'?0.25:-0.25);
      params.lfoRate = clamp(params.lfoRate+rDelta, params.lfoRateMin, params.lfoRateMax);
      if(lfoOsc) lfoOsc.frequency.setValueAtTime(params.lfoRate, audioCtx.currentTime);
    }
    if(k==='ArrowUp'||k==='ArrowDown'){ const mixDelta=(k==='ArrowUp'?0.05:-0.05); setReverbMix(params.reverbMix+mixDelta); }
    updateHUD(); e.preventDefault(); return true;
  }
  return false;
}
function toggleFullscreen(){ const el=document.documentElement; if(!document.fullscreenElement) el.requestFullscreen?.(); else document.exitFullscreen?.(); }
function clamp(v,lo,hi){ return Math.min(hi, Math.max(lo, v)); }

// Start with HUD hidden (press 1 to show)
hud.style.display = 'none';
</script>
</body>
</html>
