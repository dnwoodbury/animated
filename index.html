<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fractal Keys — with Sound</title>
  <style>
    :root { --bg: #0b0f14; }
    html, body { height: 100%; margin: 0; background: var(--bg); }
    canvas { display: block; width: 100vw; height: 100vh; }
    .hud {
      position: fixed; inset: 16px auto auto 16px; color: #cfd8e3;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: rgba(10,14,18,.55); backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 12px 14px;
      max-width: min(440px, 90vw)
    }
    .hud kbd {
      font: 600 12px/1 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      padding: 2px 6px; border-radius: 6px; background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12)
    }
    .btn {
      margin-top: 8px; display: inline-block; cursor: pointer;
      padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06); color: #e6edf7; user-select:none;
    }
    .btn:active { transform: translateY(1px) }
    .row { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud">
    <div><strong>Fractal Keys (with Sound)</strong></div>
    <div>Press any letter/number key to spawn a branching animation + a short percussive tone.</div>
    <div>Left → light & bright • Right → dark & low</div>
    <div style="opacity:.8;margin-top:6px">Try: <kbd>Q</kbd> (bright) • <kbd>P</kbd> (dark) • <kbd>Z</kbd> (bright) • <kbd>M</kbd> (dark)</div>
    <div class="row">
      <span class="btn" id="clearBtn">Clear</span>
      <span class="btn" id="pauseBtn">Pause</span>
      <span class="btn" id="muteBtn">Unmuted</span>
    </div>
  </div>

  <script>
    /* =========================
       CANVAS / FRACTAL VISUALS
       ========================= */
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let W, H, DPR;
    function resize() {
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      W = canvas.width  = Math.floor(innerWidth  * DPR);
      H = canvas.height = Math.floor(innerHeight * DPR);
      canvas.style.width  = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
    }
    addEventListener('resize', resize, { passive: true });
    resize();

    const rows = [
      "`1234567890-=",
      "qwertyuiop[]\\",
      "asdfghjkl;'",
      "zxcvbnm,./"
    ];
    const keyToIndex = (k) => {
      if (!k) return { idx: 0, max: 1 };
      const key = k.toLowerCase();
      for (const row of rows) {
        const i = row.indexOf(key);
        if (i >= 0) return { idx: i, max: row.length - 1 };
      }
      const i = Math.max(0, Math.min(11, (key.charCodeAt(0) || 0) % 12));
      return { idx: i, max: 11 };
    };
    function lightnessForKey(key) {
      const { idx, max } = keyToIndex(key);
      const t = max ? idx / max : 0;              // 0 (left) → 1 (right)
      return 85 - t * (85 - 22);
    }
    function RNG(seed) {
      let s = seed >>> 0;
      return () => {
        s ^= s << 13; s ^= s >>> 17; s ^= s << 5;
        return ((s >>> 0) / 0xffffffff);
      };
    }
    const bursts = [];
    function spawnFractalFromKey(key) {
      const now = performance.now();
      const baseL = lightnessForKey(key);
      const hue = (key.charCodeAt(0) * 11) % 360;
      const seed = key.split('').reduce((a,c)=>a + c.charCodeAt(0), 0) ^ (now|0);
      const rnd = RNG(seed);

      const start = { x: W * (0.45 + rnd()*0.1), y: H * (0.55 + rnd()*0.1) };
      const branches = [{
        x: start.x, y: start.y, angle: -Math.PI/2 + (rnd()-0.5)*0.4, len: H*0.12, depth: 0
      }];

      bursts.push({
        hue, baseL, startTime: now, life: 3200,
        branches, rnd
      });
    }
    let paused = false;
    function frame(t) {
      if (!paused) {
        ctx.fillStyle = 'rgba(11,15,20,0.12)';
        ctx.fillRect(0,0,W,H);

        for (let i=bursts.length-1; i>=0; i--) {
          const b = bursts[i];
          const age = t - b.startTime;
          if (age > b.life) { bursts.splice(i,1); continue; }
          stepBurst(b, age);
        }
      }
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    function stepBurst(b, age) {
      const speed = 1 + (age / b.life) * 1.2;
      const newBranches = [];
      for (const br of b.branches) {
        const x2 = br.x + Math.cos(br.angle) * br.len * 0.06 * speed;
        const y2 = br.y + Math.sin(br.angle) * br.len * 0.06 * speed;

        const depthT = Math.min(1, br.depth / 8);
        const l = Math.max(18, b.baseL - depthT * 50);
        ctx.strokeStyle = `hsl(${b.hue + depthT*60}, 75%, ${l}%)`;
        ctx.lineWidth = Math.max(1, (6 - br.depth) * DPR * 0.5);
        ctx.beginPath(); ctx.moveTo(br.x, br.y); ctx.lineTo(x2, y2); ctx.stroke();

        br.x = x2; br.y = y2; br.len *= 0.985;

        const willBranch = br.len > 4 * DPR && Math.random() < 0.28;
        if (willBranch && br.depth < 8) {
          const n = 2 + (Math.random() < 0.2 ? 1 : 0);
          for (let k=0; k<n; k++) {
            const ang = br.angle + (Math.random()-0.5) * (Math.PI/3);
            const child = { x: x2, y: y2, angle: ang, len: br.len * (0.72 + Math.random()*0.2), depth: br.depth + 1 };
            newBranches.push(child);
          }
        }
      }
      b.branches = b.branches
        .filter(br => br.len > 2 * DPR)
        .concat(newBranches.slice(0, 100));
    }
    function pulseAtCenter() {
      const g = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.6);
      g.addColorStop(0, 'rgba(255,255,255,0.02)');
      g.addColorStop(1, 'rgba(0,0,0,0.00)');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    }
    document.getElementById('clearBtn').onclick = () => {
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg');
      ctx.fillRect(0,0,W,H);
      bursts.length = 0;
    };
    document.getElementById('pauseBtn').onclick = (e) => {
      paused = !paused;
      e.target.textContent = paused ? 'Resume' : 'Pause';
    };
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg');
    ctx.fillRect(0,0,W,H);

    /* =========================
       AUDIO (Web Audio API)
       ========================= */
    let audioCtx = null;
    let master = null;
    let compressor = null;
    let muted = false;

    const muteBtn = document.getElementById('muteBtn');
    muteBtn.addEventListener('click', () => {
      muted = !muted;
      if (master) master.gain.value = muted ? 0 : 0.9;
      muteBtn.textContent = muted ? 'Muted' : 'Unmuted';
    });

    function ensureAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      master = audioCtx.createGain();
      master.gain.value = 0.9;

      compressor = audioCtx.createDynamicsCompressor();
      compressor.threshold.setValueAtTime(-24, audioCtx.currentTime);
      compressor.knee.setValueAtTime(30, audioCtx.currentTime);
      compressor.ratio.setValueAtTime(6, audioCtx.currentTime);
      compressor.attack.setValueAtTime(0.003, audioCtx.currentTime);
      compressor.release.setValueAtTime(0.25, audioCtx.currentTime);

      master.connect(compressor);
      compressor.connect(audioCtx.destination);
    }

    // Map keyboard column → timbre/frequency: left bright/high, right dark/low
    function soundForKey(key) {
      const { idx, max } = keyToIndex(key);
      const t = max ? idx / max : 0; // 0..1 left→right
      // Frequency range: ~880 Hz (left) down to ~110 Hz (right)
      const freq = 880 - t * (880 - 110);
      // Filter cutoff: brighter left, darker right
      const cutoff = 12000 - t * 10000; // 12k → 2k
      return { freq, cutoff, t };
    }

    function playPercussiveTone(key) {
      if (!audioCtx) ensureAudio();
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const { freq, cutoff, t } = soundForKey(key);

      // Tone oscillator (short blip)
      const osc = audioCtx.createOscillator();
      // Slightly detune right-side keys for darker character
      osc.type = t < 0.5 ? 'triangle' : 'sawtooth';
      osc.frequency.setValueAtTime(freq, now);

      // Click/noise burst for attack (for a drum-ish transient)
      const noise = audioCtx.createBufferSource();
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0; i<data.length; i++) data[i] = (Math.random()*2-1) * Math.exp(-i / (data.length*0.25));
      noise.buffer = buffer;

      // Filter to control brightness
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(cutoff, now);
      filter.Q.setValueAtTime(0.7 + t*0.6, now);

      // Envelope
      const env = audioCtx.createGain();
      const env2 = audioCtx.createGain(); // for noise
      env.gain.setValueAtTime(0, now);
      env.gain.linearRampToValueAtTime(0.9, now + 0.005);
      env.gain.exponentialRampToValueAtTime(0.0008, now + 0.35 + t*0.15);

      env2.gain.setValueAtTime(0.6, now);
      env2.gain.exponentialRampToValueAtTime(0.0008, now + 0.08 + t*0.05);

      // Light touch of stereo width via slight delay
      const delay = audioCtx.createDelay(0.02);
      delay.delayTime.setValueAtTime(0.004 + t*0.004, now);

      // Wire it up
      osc.connect(filter);
      filter.connect(env);
      env.connect(delay);
      delay.connect(master);

      noise.connect(env2);
      env2.connect(master);

      // Start/stop
      osc.start(now);
      noise.start(now);
      osc.stop(now + 0.6 + t*0.2);
      noise.stop(now + 0.12 + t*0.05);
    }

    /* =========================
       INPUT / HOOK-UP
       ========================= */
    addEventListener('keydown', async (e) => {
      if (e.repeat) return;
      const k = e.key.length === 1 ? e.key : '';
      if (!k) return;

      // Resume audio context on first interaction if suspended
      ensureAudio();
      if (audioCtx && audioCtx.state === 'suspended') {
        try { await audioCtx.resume(); } catch {}
      }

      spawnFractalFromKey(k);
      pulseAtCenter();
      if (!muted) playPercussiveTone(k);
    });
  </script>
</body>
</html>
